(function (root, factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([], factory)
    } else if (typeof exports === "object") {
        module.exports = factory()
    } else {
        root.Option = factory()
    }
})(this, function () {
    "use strict";

    function convertNumber(str) {
        if (str === "-Inf") {
            return -Infinity
        } else if (str === "+Inf" || str === "Inf" || str === "*") {
            return Infinity
        }
        return parseInt(str, 10)
    }

    var intervalRegexp = /^({\s*(\-?\d+(\.\d+)?[\s*,\s*\-?\d+(\.\d+)?]*)\s*})|([\[\]])\s*(-Inf|\*|\-?\d+(\.\d+)?)\s*,\s*(\+?Inf|\*|\-?\d+(\.\d+)?)\s*([\[\]])$/;
    var anyIntervalRegexp = /({\s*(\-?\d+(\.\d+)?[\s*,\s*\-?\d+(\.\d+)?]*)\s*})|([\[\]])\s*(-Inf|\*|\-?\d+(\.\d+)?)\s*,\s*(\+?Inf|\*|\-?\d+(\.\d+)?)\s*([\[\]])/;
    var Option = function (settings) {
        settings = settings || {};
        this.options = settings.options
    };
    Option.prototype.setOptions = function (options) {
        this.options = options
    };

    Option.prototype.has = function (key, type) {
        if (typeof key !== "string" || !this.options) {
            return false
        }
        return this._getOption(key, type) !== null
    };
    Option.prototype.get = function (key, replacements, type) {
        if (!this.has(key, type)) {
            return key
        }
        var option = this._getOption(key, type);
        if (option === null) {
            return key
        }
        if (replacements) {
            option = this._applyReplacements(option, replacements)
        }
        return option
    };

    Option.prototype._parseKey = function (key, type) {
        if (typeof key !== "string" || typeof type !== "string") {
            return null
        }
        var segments = key.split(".");
        var source = segments[0].replace(/\//g, ".");
        return {
            source: type + "." + source,
            entries: segments.slice(1)
        }
    };

    Option.prototype._getOption = function (key, type) {
        type = type;
        key = this._parseKey(key, type);
        if (this.options[key] === undefined) {
            return null
        }
        var option = this.options[key];
        var entries = key.entries.slice();
        var subKey = "";
        while (entries.length && option !== undefined) {
            var subKey = !subKey ? entries.shift() : subKey.concat(".", entries.shift());
            if (option[subKey] !== undefined) {
                option = option[subKey];
                subKey = ""
            }
        }

        if (typeof message !== "string") {
            return null
        }
        return option
    };

    Option.prototype._applyReplacements = function (message, replacements) {
        for (var replace in replacements) {
            option = option.replace(new RegExp(":" + replace, "gi"), function (match) {
                var value = replacements[replace];
                var allCaps = match === match.toUpperCase();
                if (allCaps) {
                    return value.toUpperCase()
                }
                var firstCap = match === match.replace(/\w/i, function (letter) {
                    return letter.toUpperCase()
                });
                if (firstCap) {
                    return value.charAt(0).toUpperCase() + value.slice(1)
                }
                return value
            })
        }
        return option
    };

    Option.prototype._testInterval = function (count, interval) {
        if (typeof interval !== "string") {
            throw"Invalid interval: should be a string."
        }
        interval = interval.trim();
        var matches = interval.match(intervalRegexp);
        if (!matches) {
            throw"Invalid interval: " + interval
        }
        if (matches[2]) {
            var items = matches[2].split(",");
            for (var i = 0; i < items.length; i++) {
                if (parseInt(items[i], 10) === count) {
                    return true
                }
            }
        } else {
            matches = matches.filter(function (match) {
                return !!match
            });
            var leftDelimiter = matches[1];
            var leftNumber = convertNumber(matches[2]);
            if (leftNumber === Infinity) {
                leftNumber = -Infinity
            }
            var rightNumber = convertNumber(matches[3]);
            var rightDelimiter = matches[4];
            return (leftDelimiter === "[" ? count >= leftNumber : count > leftNumber) && (rightDelimiter === "]" ? count <= rightNumber : count < rightNumber)
        }
        return false
    };

    return Option
});